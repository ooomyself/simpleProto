# 本协议格式只支持32位lua端
# support data types are following :
#									lpack	lua					nodejs.buffer
# S : string			dynamic		A 		"asdf"				b.toString('utf8', offset)
# h : short				2 bytes		>h 		-1234				b.readInt16BE(offset)
# H : unsigned short	2 bytes		>H 		1234				b.readUInt16BE(offset)
# i : int				4 bytes		>i 		-50000				b.readInt32BE(offset)
# I : unsigned int		4 bytes		>I 		50000				b.readUInt32BE(offset)
# c : char				1 bytes		c 		string.byte('c')	b.toString('ascii', offset)
# f : float				4 bytes		>f 		3.14159				b.readFloatBE(offset)
#
#	如果发现类型是 S，则先读取 1 byte 的长度（lpcak: b | nodejs.buffer: b.readUInt8(offset)），然后按照长度读取 S
#
# 协议的字节序举例：
# data  : len + msgid + S len + S       + h + i + c + f
# bytes : 2   + 2     + 2     + dynamic + 2 + 4 + 1 + 4
# 如果是服务器间消息，需要添加来源，来源由发送接口自动添加，也可以不添加，依赖服务器通信协议实现
# data  : len + msgid + src + ......
# bytes : 2   + 2     + 1   + ......
#
#	其中 len 等于除自身之外所有字节总和
#
# lua table
# [1000] = {
#     ["keys"] = { "name", "life", "kills", "herotype", "money" },
#     ["types"] = "Shicf",
#     ["target"] = "loc",
# }
#
# js object
# [1000] = {
#	"keys" : [ "name", "life", "kills", "herotype", "money" ],
#	"types" : "Shicf",
#	"target" : "loc",
# }
#
# ini file
# [1000]
# types=Shicf
# keys=name,life,kills,herotype,money
# target=loc
#
#
# key 为字母表字符

# 测试保留协议 1000 - 1100
[1000]
types=S
keys=name

[1001]
types=hHiIf
keys=a,b,c,d,e

[1002]
types=c
keys=a

[1003]
types=iSh
keys=a,b,c

[1004]
types=icf
keys=a,b,c

[1005]
types=fc
keys=a,b

[1006]
types=ScSccSSc
keys=a,b,c,d,e,f,g,h

[1007]
types=SSSSSSSSSSSSS
keys=a,b,c,d,e,f,g,h,i,j,k,l,m

[1008]
types=SI
keys=a,b
target=loc

[1009]
types=SI
keys=a,b
target=loc

